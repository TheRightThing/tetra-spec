\chapter{Introduction}
\paragraph{Abstract}
This section tells the reason why the {\tetra} project was started, what it aims to achieve, as well as some basic theoretical foundations that will be needed to appreciate the rest of this document.

\section{Motivation and goal\optional}

\paragraph{The state of computing}
Today's civilisation and digital computations have become inseparable.
Progressively, more and more in our daily lives is automated and made convenient via computers.
It is easy to see that the design of automated computing systems, be it software programs or digital circuits, is an important task.
Being fundamental to our society and its advancement, one would expect this task to be a refined vocation performed by craftsmen using the finest tools and resources.
However, the disappointing reality is that most computing systems today are designed to maximise profits, and not to maximise usefulness.
Thus, excellence is only pursued as a means to an end, and rarely an end in itself.
This leads to a self-perpetuating status quo of ``it just works'' in the world of computing.

\paragraph{The nature of programming}
Programming is the activity of abstracting complex real-world systems into idealised models, describing the desired behaviour within the model using abstract operations and concepts, and then transforming the model back into the real world.
It heavily relies on abstraction, generalisation, combination, and mutation of concepts.
The tools available today are not excellent, either:
	Most programming languages only feature very weak abstraction and generalisation of written components, and the capabilities to specialise existing components are also still in their infancy.
	Many simple abstract operations and concepts translate to large amounts of code, thus discouraging the programmer from employing them, leading to suboptimal and harder to understand system architectures.
	Most programming languages do not work with a computational framework that accurately fits the systems on which they are executed, or make unnecessarily specific assumptions about the nature of execution that narrow down the domain in which they can be employed.

\paragraph{The right thing}
The goal for {\tetra} is to provide a powerful and coherent computation framework that is very friendly to abstract operations.
It should be so general that it can be used in all fields of computational system design, while still allowing for very fine-grained control and specialisation to fulfil real-world requirements:
	it should be applicable to both digital circuits as well as computer programs.
This compatibility will give it the ability to employ the same tools for both hardware and software design, allowing refinements to the tools to be immediately useful for both disciplines.
We want to create an excellent tool that does not punish excellent ideas through artificial limitations, so abstractions, transformations, and specialisations are at the core of the framework.
The {\tetra} computation model must be capable of describing the behaviour of all possible computer program digital circuit designs.
A computation description language that fully implements {\tetra} will allow the system designer to reason about his design at several abstraction layers, and such analysis will be able to be automatised.

\section{Core concepts}
\paragraph{Nomenclature}
In the following, for improved readability, we will refer to both \emph{software programs} and \emph{circuit designs} as programs.
To specifically refer either one, we will use the terms ``software program'' or ``circuit design'', respectively.

\paragraph{Essence}
At their core, {\tetra} programs are understood as collections of \emph{independent processes} acting on \emph{objects} -- reading, modifying, creating, or destroying them.
These processes interact with each other by communicating via channels, and synchronising/notifying each other via signals.
Objects store a value of a specific type.
Types describe the structured data of objects' values, as well as their behaviour using functions.
Functions describe computations and actions on objects, and processes refer to active execution instances of functions.
With these simple ground-rules in place, we can dive deeper into the semantics of \tetra.
